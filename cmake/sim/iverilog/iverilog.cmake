include_guard(GLOBAL)

# [[[
# This function runs the Icarus Verilog (iverilog) tool on a specified IP library.
#
# The function is a wrapper around the iverilog tool and generates necessary scripts
# and configurations to compile the specified IP library.
#
# :param IP_LIB: Name of the IP library to run iverilog on.
# :type IP_LIB: string
#
# **Keyword Arguments**
#
# :keyword OUTDIR: Output directory for iverilog results. Defaults to BINARY_DIR.
# :type OUTDIR: string
# :keyword EXECUTABLE: Name of the output executable generated by iverilog. Defaults to IP_LIB_iv.
# :type EXECUTABLE: string
# ]]]
function(iverilog IP_LIB)
    # Parse the function arguments
    cmake_parse_arguments(ARG "" "TOP_MODULE;OUTDIR;EXECUTABLE;CLI_FLAGS" "" ${ARGN})
    # Check for any unrecognized arguments
    if(ARG_UNPARSED_ARGUMENTS)
        message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION} passed unrecognized argument " "${ARG_UNPARSED_ARGUMENTS}")
    endif()

    # Include the hardware IP management cmake functions
    include("${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../../hwip.cmake")

    # Assume the IP library is the latest one provided if full name is not given
    ip_assume_last(IP_LIB ${IP_LIB})
    # Get the binary directory of the IP library
    get_target_property(BINARY_DIR ${IP_LIB} BINARY_DIR)

    # Set the output directory for iverilog results
    if(NOT ARG_OUTDIR)
        set(OUTDIR ${BINARY_DIR})
    else()
        set(OUTDIR ${ARG_OUTDIR})
    endif()

    if(ARG_TOP_MODULE)
        set(TOP_MODULE "-s${ARG_TOP_MODULE}")
    endif()

    # Get the IP RTL sources
    get_ip_rtl_sources(SOURCES ${IP_LIB})
    # Where is defined V_SOURCES (if it's defined)?
    list(PREPEND SOURCES ${V_SOURCES})
    # Get IP include directories
    get_ip_include_directories(SYSTEMVERILOG_INCLUDE_DIRS ${IP_LIB} SYSTEMVERILOG)
    get_ip_include_directories(VERILOG_INCLUDE_DIRS ${IP_LIB} VERILOG)
    set(INC_DIRS ${SYSTEMVERILOG_INCLUDE_DIRS} ${VERILOG_INCLUDE_DIRS})
    # Prepare include directories arguments for iverilog
    foreach(dir ${INC_DIRS})
        list(APPEND ARG_INCDIRS -I ${dir})
    endforeach()

    # Get IP compile definitions
    get_ip_compile_definitions(COMP_DEFS_SV ${IP_LIB} SYSTEMVERILOG)
    get_ip_compile_definitions(COMP_DEFS_V ${IP_LIB} VERILOG)
    set(COMP_DEFS ${COMP_DEFS_SV} ${COMP_DEFS_V})
    # Prepare compile definitions arguments for iverilog
    foreach(def ${COMP_DEFS})
        list(APPEND CMP_DEFS_ARG -D${def})
    endforeach()

    # Set the output executable name
    if(NOT ARG_EXECUTABLE)
        set(ARG_EXECUTABLE "${OUTDIR}/${IP_LIB}_iv")
    endif()

    # Set the stamp file path (is the stamp file really needed?)
    set(STAMP_FILE "${BINARY_DIR}/${IP_LIB}_${CMAKE_CURRENT_FUNCTION}.stamp")

    # Add a custom command to run iverilog
    add_custom_command(
        OUTPUT ${ARG_EXECUTABLE} ${STAMP_FILE}
        COMMAND iverilog
        ${TOP_MODULE}
        ${ARG_INCDIRS}
        ${CMP_DEFS_ARG}
        ${ARG_CLI_FLAGS}
        -o ${ARG_EXECUTABLE}
        ${SOURCES}
        COMMAND touch ${STAMP_FILE}
        DEPENDS ${SOURCES}
        COMMENT "Running iverilog on ${IP_LIB}"
    )

    # Add a custom target that depends on the executable and stamp file
    add_custom_target(
        ${IP_LIB}_${CMAKE_CURRENT_FUNCTION}
        DEPENDS ${ARG_EXECUTABLE} ${STAMP_FILE} ${IP_LIB}
    )

    # Add a custom target to run the generated executable
    add_custom_target(
        run_${IP_LIB}_iv
        COMMAND exec ${ARG_EXECUTABLE}
        DEPENDS ${ARG_EXECUTABLE} ${STAMP_FILE} ${SOURCES} ${IP_LIB}_${CMAKE_CURRENT_FUNCTION}
    )

endfunction()

